
(* Jolk Grammar *)
(* ============ *)

unit            = [ package ] { import } { annotation } ( type_decl | extension_decl)
package         = "package" namespace  ";"
import          = "import" namespace [ ".*" ] ";"
namespace       = identifier { "." identifier }

type_decl       = [ visibility ] [ variability ] archetype type_bound "{" { type_mbr } "}"
visibility      = "public" | "package" | "protected" | "private"
variability     = "abstract" | "final"
archetype       = "class" | "value" | "record" | "enum" | "protocol"
type_bound      = type [ type_contracts ]
type            = self_type | [ namespace ] meta_id [ type_args ]
type_args       = "[" type_bound { "," type_bound } "]"
type_contracts  = "extends" type [ "implements" type { "&" type } ] | "implements" type { "&" type }
type_mbr        = { annotation } ( [ "meta" ] [ visibility ] member | enum )
member          = state | [ variability ] method
state           = ( constant | field ) ";"
constant        = "constant" type binding
field           = type identifier [ assignment ]
binding         = identifier assignment
assignment      = "=" expression
enum            = meta_id [ "(" argument_list ")" ] ";"
method          = [ "lazy" ] [ type_args ] type selector_id "(" [ typed_params ] ")" ( closure | ";" )
typed_params    = annotated_type ( instance_id { "," annotated_type instance_id } [ "," annotated_type vararg_id ] |  vararg_id )
annotated_type  = { annotation } type
vararg_id	    = "..." instance_id
extension_decl  = "extension" meta_id "extends" type "{" { extension_mbr } "}"
extension_mbr   = { annotation } [ visibility ] [ variability ] method
annotation      = "@" identifier [ "(" [ annotation_args ] ")" ]
annotation_args = annotation_arg { "," annotation_arg } | annotation_val
annotation_arg  = identifier "=" annotation_val
annotation_val  = literal | annotation | "{" [ annotation_val { "," annotation_val } ] "}"

closure         = "{" [ stat_params lambdaOp ] [ statement { ";" statement } [ ";" ] ] "}"
statement       = constant | field | binding | [ returnOp ] expression
expression      = logic_or [ condOp expression [ ":" expression ] ]
logic_or        = logic_and { "||" logic_and }
logic_and       = equality { "&&" equality }
equality        = comparison { ( "==" | "!=" | "~~" | "!~" ) comparison }
comparison      = term { ( ">" | ">=" | "<" | "<=" ) term } 
term            = factor { ( "+" | "-" ) factor }
factor          = unary { ( "*" | "/" | "%" ) unary }
unary           = ( "!" | "-" ) unary | power
power           = message [ "**" unary ]
message         = primary { selector [ ( "(" argument_list ")" | closure ) ] }
primary         = reserved | identifier | literal | list_literal | "(" expression ")" | closure
argument_list   = expression { "," expression }
stat_params     = typed_params | inferred_params
inferred_params = instance_id { "," instance_id }

reserved        = "true" | "false" | "null" | "super" | self_type | self_instance
self_type       = "Self"
self_instance   = "self"
selector_id     = identifier | operator
selector        = "#" identifier
identifier      = meta_id | instance_id
meta_id         = upper_alpha { alpha | digit }
instance_id     = lower_alpha { alpha | digit }
literal         = number_literal | string_literal | char_literal
list_literal    = array_literal | set_literal | map_literal
array_literal   = "#[" [ literal_list ] "]"
set_literal     = "#{" [ literal_list ] "}"
map_literal     = "#(" [ map_list ] ")"
literal_list    = expression { "," expression }
map_list        = map_entry { "," map_entry }
map_entry       = expression "->" expression
number_literal  = digit { digit } [ "." digit { digit } ]
string_literal  = "\"" { string_char } "\""
char_literal    = "'" single_char "'"

returnOp        = "^"
condOp          = "?" | "?!"
lambdaOp        = "->"
spreadOp        = "..."
eqOp            = "==" | "!=" | "~~" | "!~"
relOp           = ">" | ">=" | "<" | "<="
addOp           = "+" | "-" ;
mulOp           = "*" | "/" | "%"
powOp           = "**"
notOp           = "!"
negOp           = "-"

w               = sp { sp }                             (* mandatory whitespace *)
i               = { sp | nl | comment }                 (* ignorable content *)
sp              = " " | "\t"
nl              = "\n" | "\r" | "\r\n"
comment         = line_comment |  block_comment
line_comment    = "//" { "/" } { char_except_nl } nl    (* /// for markdown comment *)
block_comment   = "/*" { char_except_star_slash } "*/"
string_char     = char_except_double_quote | escape_char
single_char     = char_except_single_quote | escape_char
escape_char     = "\" ( "b" | "t" | "n" | "f" | "r" | "\"" | "'" | "\" )
operator        = "+" | "-" | "*" | "/" | "%" | "==" | "!=" | "~~" | "!~" | ">" | ">=" | "<" | "<=" | "!" | "**" | "?" | "?!"